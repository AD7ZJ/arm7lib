/***************************************************************************
 *                                                                         *
 *  This program is free software; you can redistribute it and/or modify   *
 *  it under the terms of the GNU General Public License as published by   *
 *  the Free Software Foundation; either version 2 of the License, or      *
 *  (at your option) any later version.                                    *
 *                                                                         *
 *  This program is distributed in the hope that it will be useful,        *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of         *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
 *  GNU General Public License for more details.                           *
 *                                                                         *
 *  You should have received a copy of the GNU General Public License      *
 *  along with this program; if not, write to the Free Software            *
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111 USA    *
 *                                                                         *
 ***************************************************************************
 *                                                                         *
 *               (c) Copyright, 1997-2012, ANSR                            *
 *                                                                         *
 ***************************************************************************
 *                                                                         *
 * Filename:     USB.cpp                                                   *
 *                                                                         *
 ***************************************************************************/

#include "armlib.h"

// C header files for USB library support.
extern "C"
{
#include "type.h"
#include "usbdebug.h"

#include "usbapi.h"
}

// Macro to generate two bytes from a 16-bit word.
#define LE_WORD(x) ((x)&0xFF),((x)>>8)

// Input interrupt end point.
const uint32_t INTR_IN_EP = 0x81;

// Output interrupt end point.
const uint32_t INTR_OUT_EP = 0x01;

// USB packet size limit for high speed HID device.
const uint32_t MAX_PACKET_SIZE = 64;

// Device status ready.
const uint32_t READY_STATUS = 0x11;

static int _iIdleRate = 0;

/// HID Report generated by HID Descriptor Tool (DT) from USBHIDReport.hid.  The tool is available from usb.org
static uint8_t abReportDesc[34] =
{
    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)
    0x09, 0x01,                    // USAGE (Vendor Usage 1)
    0xa1, 0x01,                    // COLLECTION (Application)
    0x09, 0x01,                    //   USAGE (Vendor Usage 1)
    0x09, 0x01,                    //   USAGE (Vendor Usage 1)
    0x15, 0x80,                    //   LOGICAL_MINIMUM (-128)
    0x25, 0x7f,                    //   LOGICAL_MAXIMUM (127)
    0x75, 0x08,                    //   REPORT_SIZE (8)
    0x95, 0x40,                    //   REPORT_COUNT (64)
    0x81, 0x02,                    //   INPUT (Data,Var,Abs)
    0x09, 0x01,                    //   USAGE (Vendor Usage 1)
    0x15, 0x80,                    //   LOGICAL_MINIMUM (-128)
    0x25, 0x7f,                    //   LOGICAL_MAXIMUM (127)
    0x75, 0x08,                    //   REPORT_SIZE (8)
    0x95, 0x40,                    //   REPORT_COUNT (64)
    0x91, 0x02,                    //   OUTPUT (Data,Var,Abs)
    0xc0                           // END_COLLECTION
};

/// Base HID descriptor table before adding manufacturer, product, and serial number strings.
static const uint8_t baseHIDDescriptor[63] =
{
    // Device descriptor
    0x12,
    DESC_DEVICE,
    LE_WORD(0x0200),        // bcdUSB
    0x00,                   // bDeviceClass
    0x00,                   // bDeviceSubClass
    0x00,                   // bDeviceProtocol
    MAX_PACKET_SIZE0,       // bMaxPacketSize
    LE_WORD(0x0000),        // idVendor
    LE_WORD(0x0000),        // idProduct
    LE_WORD(0x0100),        // bcdDevice
    0x01,                   // iManufacturer
    0x02,                   // iProduct
    0x03,                   // iSerialNumber
    0x01,                   // bNumConfigurations

    // Configuration
    0x09,
    DESC_CONFIGURATION,
    LE_WORD(0x29),          // wTotalLength
    0x01,                   // bNumInterfaces
    0x01,                   // bConfigurationValue
    0x00,                   // iConfiguration
    0x80,                   // bmAttributes
    0x00,                   // bMaxPower

    // Interface
    0x09,
    DESC_INTERFACE,
    0x00,                   // bInterfaceNumber
    0x00,                   // bAlternateSetting
    0x02,                   // bNumEndPoints   was 0x01
    0x03,                   // bInterfaceClass = HID
    0x00,                   // bInterfaceSubClass
    0x00,                   // bInterfaceProtocol
    0x00,                   // iInterface

    // HID descriptor
    0x09,
    DESC_HID_HID,           // bDescriptorType = HID
    LE_WORD(0x0110),        // bcdHID
    0x00,                   // bCountryCode
    0x01,                   // bNumDescriptors = report
    DESC_HID_REPORT,        // bDescriptorType
    LE_WORD(sizeof(abReportDesc)),

    // EP descriptor
    0x07,
    DESC_ENDPOINT,
    INTR_IN_EP,             // bEndpointAddress
    0x03,                   // bmAttributes = INT
    LE_WORD(MAX_PACKET_SIZE),// wMaxPacketSize
    1,                      // bInterval

    // EP descriptor
    0x07,
    DESC_ENDPOINT,
    INTR_OUT_EP,             // bEndpointAddress
    0x03,                   // bmAttributes = INT
    LE_WORD(MAX_PACKET_SIZE),// wMaxPacketSize
    1,                      // bInterval

    // String descriptors
    0x04,
    DESC_STRING,
    LE_WORD(0x0409)
};

/// Reserve memory for singleton object.
static USB usbSingletonObject;

/**
 * Get a pointer to the USB singleton object.
 */
USB *USB::GetInstance()
{
    return &usbSingletonObject;
}

/**
 * Constructor.
 */
USB::USB()
{
    this->writeFlag = false;
    this->connectFlag = false;
    this->wasConnectedFlag = false;
}

/**
 * HID class request handler
 *
 * @param pSetup pointer to TSetupPacket structure
 * @param piLen number of elements populated in return structure
 * @param ppbData array of pointers
 *
 * @return true if requested handled; otherwise false
 */
BOOL HandleClassRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
    U8  *pbData = *ppbData;

    switch (pSetup->bRequest) {

    // get_idle
    case HID_GET_IDLE:
        pbData[0] = (_iIdleRate / 4) & 0xFF;
        *piLen = 1;
        break;

    // set_idle:
    case HID_SET_IDLE:
        _iIdleRate = ((pSetup->wValue >> 8) & 0xFF) * 4;
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

/**
 * Standard request handler for HID devices.  This function tries to service any HID specific requests.
 */
BOOL HIDHandleStdReq(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
    U8  bType, bIndex;

    if ((pSetup->bmRequestType == 0x81) &&          // standard IN request for interface
        (pSetup->bRequest == REQ_GET_DESCRIPTOR)) { // get descriptor

        bType = GET_DESC_TYPE(pSetup->wValue);
        bIndex = GET_DESC_INDEX(pSetup->wValue);
        switch (bType) {

        case DESC_HID_REPORT:
            // report
            *ppbData = abReportDesc;
            *piLen = sizeof(abReportDesc);
            break;

        case DESC_HID_HID:
        case DESC_HID_PHYSICAL:
        default:
            // search descriptor space
            return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);
        }

        return TRUE;
    }
    return FALSE;
}

/**
 * Process the end point interrupt callback.
 *
 * @param ep end point to service
 * @param status from hardware interrupt register
 */
void USB::InterruptEP(uint8_t ep, uint8_t status)
{
    uint32_t ret;
    uint8_t data[USBHIDReport::REPORT_SIZE];

    if (ep == INTR_OUT_EP)
    {
        // Get the data from the USB hardware.
        ret = USBHwEPRead(INTR_OUT_EP, data, USBHIDReport::REPORT_SIZE);

        // Only push the data to the FIFO if it is the size of the HID Report.
        if (ret == USBHIDReport::REPORT_SIZE)
            this->fifo.Push(data);

    } else {
        this->writeFlag = false;
    } // END switch
}

/**
 * Process the device status callback.
 *
 * @param status bitmap mask of the type DEV_STATUS_*
 */
void USB::DeviceStatus(uint8_t status)
{
    if (status == READY_STATUS)
    {
        this->connectReadyTime = SystemControl::GetTick() + 500;
        this->connectFlag = true;
    } else {
        this->connectFlag = false;
        this->wasConnectedFlag = false;
    } // END if-else
}

/**
 * Append a string descriptor to the USB HID Descriptor structure.
 *
 * @param offset to start new descriptor
 * @param text pointer to NULL terminated string to append
 *
 * @return offset after adding descriptor
 */
uint32_t USB::AddDescriptorString(uint32_t offset, const char *text)
{
    this->HIDDescriptor[offset++] = 2 + (std::strlen(text) << 1);

    this->HIDDescriptor[offset++] = DESC_STRING;

    while (*text != 0)
    {
        this->HIDDescriptor[offset++] = *text++;
        this->HIDDescriptor[offset++] = 0x00;
    } // END while

    return offset;
}

/**
 * Configure the USB hardware and software stack for operation.
 *
 * @param vendorID unique vendor ID that identifies the device
 * @param productID unique product ID that identifies the device
 * @param manufacturer NULL terminated string of the device manufacturer
 * @param product NULL terminated string of the device manufacturer
 * @param serialNumber NULL terminated string of the serial number
 */
void USB::Enable(uint32_t vendorID, uint32_t productID, const char *manufacturer, const char *product, const char *serialNumber)
{
    uint32_t index;

    // Copy the HID Descriptor up to the strings.
    std::memcpy (this->HIDDescriptor, baseHIDDescriptor, sizeof(baseHIDDescriptor));

    // Insert the vendor and product ID little endian first.
    this->HIDDescriptor[8] = vendorID & 0xff;
    this->HIDDescriptor[9] = (vendorID >> 8) & 0xff;

    this->HIDDescriptor[10] = productID & 0xff;
    this->HIDDescriptor[11] = (productID >> 8) & 0xff;

    // Set a pointer to the end of the base descriptors.
    index = sizeof(baseHIDDescriptor);

    // Add in each of the manufacturer, product, and serial number strings.
    index = AddDescriptorString(index, manufacturer);
    index = AddDescriptorString(index, product);
    index = AddDescriptorString(index, serialNumber);

    // Terminate all the strings.
    this->HIDDescriptor[index] = 0;

    // Initialize the stack.
    USBInit();

    // Register device descriptors.
    USBRegisterDescriptors(this->HIDDescriptor);

    // Register HID standard request handler
    USBRegisterCustomReqHandler(HIDHandleStdReq);

    // Register the device status handler.
    USBHwRegisterDevIntHandler(DeviceStatusCallback);

    // Register class request handler.
    USBRegisterRequestHandler(REQTYPE_TYPE_CLASS, HandleClassRequest, abClassReqData);

    // Register the input and output end point interrupt handler.  We use the same interrupt handler because the USB driver only allows a single callback per end point.
    USBHwRegisterEPIntHandler(INTR_IN_EP, InterruptEPCallback);
    USBHwRegisterEPIntHandler(INTR_OUT_EP, InterruptEPCallback);

    // Add the USB interrupt handler.
    VICVectAddr3 = reinterpret_cast <uint32_t> (USBHwISR);
    VICVectCntl3 = VICVectCntl_ENABLE | VIC_Channel_USB;
    VICIntEnable = (1 << VIC_Channel_USB);

    // Connect to the USB Bus.
    USBHwConnect(TRUE);
}

/**
 * Determine if a USB interrupt source is pending and call the USB Interrupt Handler
 * that is part of the USB library.  This method is useful for applications that don't
 * want to enable the actual interrupt service.
 */
void USB::CheckInterrupt()
{
    if (VICRawIntr & VIC_USB_Intr)
        USBHwISR();
}

/**
 * Send a HID report to the host.
 *
 * @param report pointer to USB HID Report class
 */
void USB::Send (USBHIDReport *report)
{
    uint32_t endTime;

    if (!this->connectFlag || this->connectReadyTime > SystemControl::GetTick())
        return;

    endTime = SystemControl::GetTick() + 5;

    // Wait for the current write operation to complete before we send another report.
    while (this->writeFlag && SystemControl::GetTick() < endTime);

    if (SystemControl::GetTick() >= endTime)
        UART0::GetInstance()->WriteLine ("USB write timeout");

    // Set a flag to indicate a write is in progress.
    this->writeFlag = true;

    // Write the report to the stack.
    USBHwEPWrite(INTR_IN_EP, report->Payload(), USBHIDReport::REPORT_SIZE);
}

/**
 * Indicates if an USB HID Report is in the FIFO queue.
 *
 * @return true to indicate there is a waiting report
 */
bool_t USB::HasHIDReport()
{
    return this->fifo.HasEntry();
}

/**
 * Return the oldest HID Report from the incoming message FIFO.
 *
 * @return pointer to HIDReport object; otherwise NULL if FIFO is empty
 */
USBHIDReport *USB::HIDReport()
{
    return this->fifo.Pop();
}

/**
 * One shot event that indicates the USB device was connected.
 *
 * @return true once for every time the USB is connected to the host; otherwise false
 */
bool_t USB::IsConnected()
{
    if (this->wasConnectedFlag)
        return false;

    if (this->connectFlag && SystemControl::GetTick() > this->connectReadyTime)
    {
        this->wasConnectedFlag = true;
        return true;
    }

    return false;
}

/**
 * Indicates if the USB port is currently connection.
 */
bool_t USB::IsActive()
{
    if (this->connectFlag && SystemControl::GetTick() > this->connectReadyTime)
        return true;

    return false;
}

/**
 * Send a text debug message via USB to the Windows application.
 *
 * @param text pointer to format string and optional parameters
 */
void USB::Debug(const char *text, ...)
{
    va_list argList;
    USBHIDReport report;

    report.MessageID(HID_MESSAGE_ID_SYSTEM_DEBUG);

    va_start (argList, text);
    vsnprintf (reinterpret_cast<char *> (report.Report()), USBHIDReport::REPORT_SIZE - 1, text, argList);
    va_end (argList);

    Send(&report);
}
